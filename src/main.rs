use std::{env, fs};
use std::ops::BitOr;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {
    let mut args = env::args();
    let wasm_source = &args.nth(0).expect("The first argument should be the wasm file");
    assert!(wasm_source.ends_with(".wasm"));
    let jvm_sink = &args.nth(1).expect("The second argument should be jvm class file to create");
    assert!(jvm_sink.ends_with(".class"));

    fs::read(wasm_source)?.into_iter()
        .fold(Class::new(), parse_wasm_byte)
        .write(jvm_sink)
}

fn parse_wasm_byte(class: Class, byte: u8) -> Class {
    class
}

/// A JVM Class file
/// See: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1
struct Class {
    magic: u32,
    minor_version: u16,
    major_version: u16,
    constant_pool: Vec<ConstantPoolInfo>,
    access_flags: u16,
    this_class: u16,
    super_class: u16,
    interfaces: Vec<u16>,
    fields: Vec<FieldInfo>,
    methods: Vec<MethodInfo>,
    attributes: Vec<AttributeInfo>
}

impl Class {
    pub fn new() -> Self {
        Self {
            magic: 0xCAFEBABE,
            minor_version: 0,
            major_version: 52, // Java 1.8
            constant_pool: vec![],
            access_flags: Access::Public | Access::Final | Access::Synthetic,
            this_class: 0,
            super_class: 0,
            interfaces: vec![],
            fields: vec![],
            methods: vec![],
            attributes: vec![],
        }
    }

    pub fn write<P: AsRef<Path>>(self, path: P) -> Result<(), Box<dyn std::error::Error + 'static>> {
        Ok(())
    }
}

struct ConstantPoolInfo {

}

#[repr(u8)]
enum Constant {
    Class = 7,
    FieldRef = 9,
    MethodRef = 10,
    InterfaceMethodRef = 11,
    String = 8,
    Integer = 3,
    Float = 4,
    Long = 5,
    Double = 6,
    NameAndType = 12,
    Utf8 = 1,
    MethodHandle = 15,
    MethodType = 16,
    InvokeDynamic = 18
}

#[repr(u16)]
enum Access {
    /// Declared public; may be accessed from outside its package.
    Public = 0x0001,
    /// Declared final; no subclasses allowed.
    Final = 0x0010,
    /// Treat superclass methods specially when invoked by the `invokespecial` instruction.
    Super = 0x0020,
    /// Is an interface, not a class.
    Interface = 0x0200,
    /// Declared abstract; must not be instantiated.
    Abstract = 0x0400,
    /// Declared synthetic; not present in the source code. Indicates that this class or interface was generated by a compiler.
    Synthetic = 0x1000,
    /// Declared as an annotation type.
    Annotation = 0x2000,
    /// Declared as an enum type. 
    Enum = 0x4000
}



struct FieldInfo {

}

struct MethodInfo {

}

struct AttributeInfo {

}

impl BitOr<Access> for u16 {
    type Output = u16;

    fn bitor(self, rhs: Access) -> Self::Output {
        let rhs = rhs as u16;
        self | rhs
    }
}

impl BitOr for Access {
    type Output = u16;

    fn bitor(self, rhs: Self) -> Self::Output {
        let lhs = self as u16;
        let rhs = rhs as u16;
        lhs | rhs
    }
}